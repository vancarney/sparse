// Generated by CoffeeScript 1.7.1
(function() {
  var Backbone, global, sparse, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  global = exports || window;

  if (typeof exports !== 'undefined') {
    _ = require('underscore')._;
    Backbone = require('backbone');
  }

  if (!global.sparse) {
    sparse = global.sparse = {
      VERSION: '0.3.1-alpha',
      APP_ID: void 0,
      REST_KEY: void 0,
      SESSION_TOKEN: void 0,
      API_VERSION: '1',
      MAX_BATCH_SIZE: 50,
      DEFAULT_FETCH_LIMIT_OVERRIDE: 200000,
      UNDEFINED_CLASSNAME: '__UNDEFINED_CLASSNAME__',
      API_URI: 'https://api.parse.com/1',
      CRUD_METHODS: {
        create: 'POST',
        read: 'GET',
        update: 'PUT',
        destroy: 'DELETE'
      }
    };
    sparse.initialize = function(app_id, rest_key) {
      sparse.APP_ID = app_id;
      return sparse.REST_KEY = rest_key;
    };
  }

  sparse.apiOPTS = function() {
    return {
      contentType: "application/json",
      processData: false,
      dataType: 'json',
      data: null,
      headers: {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': sparse.APP_ID,
        'X-Parse-REST-API-Key': sparse.REST_KEY,
        'X-Parse-Session-Token': sparse.SESSION_TOKEN
      }
    };
  };

  sparse.regEscape = function(string) {
    return string.replace(/([\^\/\.\-\+\*\[\]\{\}\|\(\)\?\$]+)/g, '\\$1');
  };

  sparse.validateRoute = function(route) {
    if (!route.match(new RegExp("^(" + (sparse.regEscape(sparse.API_URI)) + "\/)?(batch|classes|events|files|functions|login|push|requestPasswordReset|users|jobs)+"))) {
      throw "Bad route: " + route;
    }
    return true;
  };

  sparse._parseDate = function(iso8601) {
    var t;
    if ((t = iso8601.match(/^([0-9]{1,4})\-([0-9]{1,2})\-([0-9]{1,2})T+([0-9]{1,2}):+([0-9]{1,2}):?([0-9]{1,2})?(.([0-9]+))?Z+$/)) === null) {
      return null;
    }
    return new Date(Date.UTC(t[1] || 0, (t[2] || 1) - 1, t[3] || 0, t[4] || 0, t[5] || 0, t[6] || 0, t[8] || 0));
  };

  sparse.getConstructorName = function(fun) {
    var n;
    return fun.constructor.name || ((n = fun.constructor.toString().match(/function+\s{1,}([A-Z]{1}[a-zA-Z]*)/)) != null ? n[1] : sparse.UNDEFINED_CLASSNAME);
  };

  sparse._encode = function(value, seenObjects, disallowObjects) {
    var o;
    if (value instanceof sparse.Model && disallowObjects) {
      throw "sparse.Models not allowed here";
    }
    if (value instanceof sparse.Object && (value._toPointer != null) && typeof value._toPointer === 'function') {
      return value._toPointer();
    }
    if (value.hasOwnProperty('dirty' && typeof value.dirty === 'Function' && !value.dirty())) {
      return sparse._encode(value._toFullJSON(seenObjects = seenObjects.concat(value)), seenObjects, disallowObjects);
    }
    if (value instanceof sparse.Object && value.isNew()) {
      throw 'Tried to save Model with a Pointer to an new or unsaved Object.';
    }
    if (_.isDate(value)) {
      return {
        __type: Date,
        iso: value.toJSON()
      };
    }
    if (_.isArray(value)) {
      return _.map(value, (function(v) {
        return sparse._encode(v, seenObjects, disallowObjects);
      }));
    }
    if (_.isRegExp(value)) {
      return value.source;
    }
    if ((sparse.Relation && value instanceof sparse.Relation) || (sparse.Op && value instanceof sparse.Op) || (sparse.GeoPoint && value instanceof sparse.GeoPoint)) {
      return value.toJSON();
    }
    if (sparse.File && value instanceof sparse.File) {
      if (!value.url()) {
        throw 'Tried to save an object containing an unsaved file.';
      }
      return {
        __type: "File",
        name: value.name(),
        url: value.url()
      };
    }
    if (_.isObject(value)) {
      o = {};
      _.each(value, function(v, k) {
        return o[k] = sparse._encode(v, seenObjects, disallowObjects);
      });
      return o;
    }
    return value;
  };

  sparse._decode = function(key, value) {
    var cN, f, o, p, r;
    if (!_.isObject(value)) {
      return value;
    }
    if (_.isArray(value)) {
      _.each(value, function(v, k) {
        return value[k] = sparse._decode(k, v);
      });
      return value;
    }
    if ((value instanceof sparse.Object) || (sparse.File && value instanceof sparse.File) || (sparse.OP && value instanceof sparse.Op)) {
      return value;
    }
    if (value.__op) {
      return sparse.OP._decode(value);
    }
    if (value.__type && value.__type === 'Pointer') {
      p = sparse.Object._create(value.className);
      p._finishFetch({
        objectId: value.objectId
      }, false);
      return p;
    }
    if (value.__type && value.__type === 'Object') {
      cN = value.className;
      delete value.__type;
      delete value.className;
      o = sparse.Object._create(cN);
      o._finishFetch(value, true);
      return o;
    }
    if (value.__type === 'Date') {
      return sparse._parseDate(value.iso);
    }
    if (sparse.GeoPoint && value.__type === 'GeoPoint') {
      return new sparse.GeoPoint({
        latitude: value.latitude,
        longitude: value.longitude
      });
    }
    if (sparse.Relation && value.__type === 'Relation') {
      (r = new sparse.Relation(null, key)).targetClassName = value.className;
      return r;
    }
    if (sparse.File && value.__type === 'File') {
      (f = new sarse.File(value.name)).url = value.url;
      return f;
    }
    _.each(value, function(v, k) {
      return value[k] = sparse._decode(k, v);
    });
    return value;
  };

  sparse.Inflection = new (function() {
    return {
      __uncountable_words: ['equipment', 'information', 'rice', 'money', 'species', 'series', 'fish', 'sheep', 'moose', 'deer', 'news'],
      __plural_rules: [[/(m)an$/gi, '$1en'], [/(pe)rson$/gi, '$1ople'], [/(child)$/gi, '$1ren'], [/^(ox)$/gi, '$1en'], [/(ax|test)is$/gi, '$1es'], [/(octop|vir)us$/gi, '$1i'], [/(alias|status)$/gi, '$1es'], [/(bu)s$/gi, '$1ses'], [/(buffal|tomat|potat)o$/gi, '$1oes'], [/([ti])um$/gi, '$1a'], [/sis$/gi, 'ses'], [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'], [/(hive)$/gi, '$1s'], [/([^aeiouy]|qu)y$/gi, '$1ies'], [/(x|ch|ss|sh|lens)$/gi, '$1es'], [/(matr|vert|ind)ix|ex$/gi, '$1ices'], [/([m|l])ouse$/gi, '$1ice'], [/(quiz)$/gi, '$1zes'], [/s$/gi, 's'], [/$/gi, 's']],
      apply_rules: function(str, rules, skip) {
        var rx;
        if ((skip.indexOf(str.toLowerCase())) === -1) {
          if ((rx = _.find(rules, (function(_this) {
            return function(itm) {
              return str.match(itm[0]);
            };
          })(this))) != null) {
            return str.replace(rx[0], rx[1]);
          }
        }
        return str;
      },
      pluralize: function(str) {
        return this.apply_rules(str, this.__plural_rules, this.__uncountable_words);
      }
    };
  });

  sparse.Object = (function(_super) {
    __extends(Object, _super);

    Object.prototype.idAttribute = 'objectId';

    function Object(attrs, opts) {
      Object.__super__.constructor.call(this, attrs, opts);
      if ((this.className != null ? this.className : this.className = sparse.getConstructorName(this)) === sparse.UNDEFINED_CLASSNAME) {
        console.warn('sparse.Object requires className to be defined');
      } else {
        this.className = sparse.Inflection.pluralize(this.className);
      }
    }

    Object.prototype.query = function() {
      if (this._query == null) {
        this._query = new sparse.Query(this.className);
      }
      return this._query;
    };

    Object.prototype.url = function() {
      return "" + sparse.API_URI + "/classes/" + this.className + (!this.isNew() ? '/' + (this.get('objectId')) : '');
    };

    Object.prototype.sync = function(method, model, options) {
      var encode, opts;
      if (options == null) {
        options = {};
      }
      opts = sparse.apiOPTS();
      encode = function(o) {
        if (_.isObject(o && o.hasOwnProperty('_toPointer' && typeof o._toPointer === 'function'))) {
          o = o._toPointer();
        }
        return o;
      };
      if (method.match(/^(create|read)+$/)) {
        _.each(model.attributes, (function(_this) {
          return function(v, k) {
            if (_.isObject(v)) {
              v = encode(v);
            }
            if (_.isArray(v)) {
              return _.map(v, function(o) {
                if (_.isObject) {
                  return encode(o);
                } else {
                  return o;
                }
              });
            }
          };
        })(this));
      }
      opts.data = !this._query ? JSON.stringify(this.toJSON()) : "where=" + (this._query.toJSON());
      sparse.validateRoute(options.url != null ? options.url : options.url = _.result(this, 'url') || '/');
      return Object.__super__.sync.call(this, method, model, _.extend(options, opts));
    };

    Object.prototype.set = function(attrs, opts) {
      var s;
      s = Object.__super__.set.call(this, attrs, opts);
      if (this.changedAttributes()) {
        this.__isDirty = true;
      }
      return s;
    };

    Object.prototype.save = function(attributes, options) {
      var children, files, self;
      if (options == null) {
        options = {};
      }
      self = this;
      sparse.Object._findUnsavedChildren(this.attributes, children = [], files = []);
      if (children.length) {
        return sparse.Object.saveAll(children, {
          completed: (function(_this) {
            return function(m, r, o) {
              var rt;
              if ((m.responseText != null) && (rt = JSON.parse(m.responseText)) instanceof Array) {
                _.each(_this.attributes, function(v, k) {
                  var p;
                  if (v instanceof sparse.Object && (typeof v.get === "function" ? v.get('objectId') : void 0) === rt[0].success.objectId) {
                    console.log(p = v._toPointer());
                    return _this.attributes[k] = {
                      __op: "AddRelation",
                      objects: [p]
                    };
                  }
                });
              }
              return Object.__super__.save.call(self, attributes, {
                success: function() {
                  console.log('saved object!');
                  return typeof options.completed === "function" ? options.completed(m, r, o) : void 0;
                },
                error: function() {
                  return console.log('save failed');
                }
              });
            };
          })(this),
          success: (function(_this) {
            return function(m, r, o) {
              return typeof options.success === "function" ? options.success(m, r, o) : void 0;
            };
          })(this),
          error: (function(_this) {
            return function(m, r, o) {
              return typeof options.error === "function" ? options.error(m, r, o) : void 0;
            };
          })(this)
        });
      } else {
        return Object.__super__.save.call(this, attributes, options);
      }
    };

    Object.prototype.toJSON = function(options) {
      var data;
      data = Object.__super__.toJSON.call(this, options);
      delete data.createdAt;
      delete data.updatedAt;
      return data;
    };

    Object.prototype._toFullJSON = function(seenObjects) {
      var json;
      _.each((json = _.clone(this.attributes)), function(v, k) {
        return json[key] = sparse._encode(v, seenObjects);
      });
      _.each(this.__op, function(v, k) {
        return json[v] = k;
      });
      if (_.has(this, 'id')) {
        json.objectId = this.id;
      }
      if (_.has(this, 'createdAt')) {
        json.createdAt = (_.isDate(this.createdAt) ? this.createdAt.toJSON() : this.createdAt);
      }
      if (_.has(this, 'updatedAt')) {
        json.updatedAt = (_.isDate(this.updatedAt) ? this.updatedAt.toJSON() : this.updatedAt);
      }
      json.__type = 'Object';
      json.className = this.className;
      return json;
    };

    Object.prototype.nestCollection = function(aName, nCollection) {
      var i, item, _i, _len;
      for (i = _i = 0, _len = nCollection.length; _i < _len; i = ++_i) {
        item = nCollection[i];
        this.attributes[aName][i] = (nCollection.at(i)).attributes;
      }
      nCollection.bind('add', (function(_this) {
        return function(initiative) {
          if (!_this.get(aName)) {
            _this.attributes[aName] = [];
          }
          return (_this.get(aName)).push(initiative.attributes);
        };
      })(this));
      nCollection.bind('remove', (function(_this) {
        return function(initiative) {
          var updateObj;
          updateObj = {};
          updateObj[aName] = _.without(_this.get(aName), initiative.attributes);
          return _this.set(updateObj);
        };
      })(this));
      return nCollection;
    };

    Object.prototype.__op = {};

    Object.prototype._serverData = {};

    Object.prototype._opSetQueue = [{}];

    Object.prototype.__isDirty = false;

    Object.prototype.dirty = function() {
      return this.__isDirty || this.hasChanged();
    };

    Object.prototype._toPointer = function() {
      if (this.isNew()) {
        throw new Error('Can\'t serialize an unsaved sparse.Object');
      }
      return {
        __type: 'Pointer',
        className: this.className,
        objectId: this.id
      };
    };

    Object.prototype._finishFetch = function(serverData, hasData) {
      console.log("_finishFetch");
      this._opSetQueue = [{}];
      this._mergeMagicFields(serverData);
      _.each(serverData, (function(_this) {
        return function(v, k) {
          return _this._serverData[key] = sparse._decode(k, v);
        };
      })(this));
      this._hasData = hasData;
      return this.__isDirty = false;
    };

    Object.prototype._mergeMagicFields = function(attrs) {
      return _.each(['id', 'objectId', 'createdAt', 'updatedAt'], (function(_this) {
        return function(attr) {
          if (attrs[attr]) {
            switch (attrs[attr]) {
              case 'objectId':
                _this.id = attrs[attr];
                break;
              case 'createdAt':
              case 'updatedAt':
                _this[attr] = !_.isDate(attrs[attr]) ? sparse._parseDate(attrs[attr]) : attrs[attr];
            }
            return delete attrs[attr];
          }
        };
      })(this));
    };

    Object.prototype.add = function(attr, objects) {
      var a;
      if (_.isArray((a = this.get('attr')))) {
        this.set(({}[attr] = a.concat(objects)), null);
      }
      return this.changedAttributes();
    };

    Object.prototype.addUnique = function(attr, objects) {
      var a;
      if (_.isArray((a = this.get('attr')))) {
        this.set(({}[attr] = _.union(a, objects)), null);
      }
      return this.changedAttributes();
    };

    Object.prototype.increment = function(attr, amount) {
      var a;
      if (_.isNumber((a = this.get('attr')))) {
        this.set({}[attr] = a + (amount != null ? amount : amount = 1), null);
      }
      return this.changedAttributes();
    };

    return Object;

  })(Backbone.Model);

  sparse.Object._classMap = {};

  sparse.Object._getSubclass = function(className) {
    var clazz, _base;
    if (!_.isString(className)) {
      throw 'sparse.Object._getSubclass requires a string argument.';
    }
    return (_base = sparse.Object._classMap)[className] != null ? _base[className] : _base[className] = (clazz = sparse.Object._classMap[className]) ? clazz : sparse.Object.extend(className);
  };

  sparse.Object._findUnsavedChildren = function(object, children, files) {
    return _.each(object, (function(_this) {
      return function(obj) {
        if (obj instanceof sparse.Object) {
          if (obj.dirty()) {
            children.push(obj);
          }
        }
      };
    })(this));
  };

  sparse.Object._create = function(className, attr, opts) {
    var clazz;
    if (typeof (clazz = sparse.Object._getSubclass(className)) === 'function') {
      return new clazz(attr, opts);
    } else {
      throw "unable to create " + className;
    }
  };

  sparse.Object.saveAll = function(list, options) {
    return (new sparse.Batch(list)).exec({
      success: (function(_this) {
        return function(m, r, o) {
          if (options.success) {
            return options.success(m, r, o);
          }
        };
      })(this),
      completed: (function(_this) {
        return function(m, r, o) {
          if (options.completed) {
            return options.completed(m, r, o);
          }
        };
      })(this),
      error: (function(_this) {
        return function(m, r, o) {
          if (options.error) {
            return options.error(m, r, o);
          }
        };
      })(this)
    });
  };

  sparse.Object.destroyAll = function(list, options) {
    return (new sparse.Batch).destroy(list, {
      success: (function(_this) {
        return function(m, r, o) {
          if (options.success) {
            return options.success(m, r, o);
          }
        };
      })(this),
      complete: (function(_this) {
        return function(m, r, o) {
          if (options.complete) {
            return options.complete(m, r, o);
          }
        };
      })(this),
      error: (function(_this) {
        return function(m, r, o) {
          if (options.error) {
            return options.error(m, r, o);
          }
        };
      })(this)
    });
  };

  sparse.Model = sparse.Object;

  sparse.Collection = (function(_super) {
    __extends(Collection, _super);

    Collection.prototype.__count = void 0;

    Collection.prototype.count = function() {
      return this.__count || this.models.length;
    };

    Collection.prototype.__params = {
      limit: sparse.DEFAULT_FETCH_LIMIT_OVERRIDE,
      count: 1
    };

    Collection.prototype.getParams = function() {
      return (_.map(_.pairs(this.__params || null), (function(_this) {
        return function(v, k) {
          return v.join('=');
        };
      })(this))).join('&');
    };

    Collection.prototype.url = function() {
      var p;
      return encodeURI("" + sparse.API_URI + "/classes/" + this.className + (this.__method === 'read' && (p = this.getParams()).length ? '?' + p : ''));
    };

    Collection.prototype.parse = function(options) {
      var data;
      return (data = Collection.__super__.parse.call(this, options)).results || data;
    };

    Collection.prototype.sync = function(__method, model, options) {
      var opts;
      this.__method = __method;
      if (options == null) {
        options = {};
      }
      opts = sparse.apiOPTS();
      if (this.__method === sparse.CRUD_METHODS.read) {
        _.each(['order', 'count', 'limit', 'where'], (function(_this) {
          return function(v, k) {
            if (options[v]) {
              _this.__params[v] = (JSON.stringify(options[v])).replace(/\\{2}/g, '\\');
              return delete options[v];
            }
          };
        })(this));
      }
      console.log(this.__params);
      opts.success = (function(_this) {
        return function(m, r, o) {
          _this.__params = {
            limit: sparse.DEFAULT_FETCH_LIMIT_OVERRIDE,
            count: 1
          };
          if (options.success != null) {
            return options.success(m, r, o);
          }
        };
      })(this);
      opts.error = (function(_this) {
        return function(m, r, o) {
          if (options.error) {
            return options.error(m, r, o);
          }
        };
      })(this);
      return Collection.__super__.sync.call(this, this.__method, this, _.extend(_.clone(options), opts));
    };

    Collection.prototype.query = function(query, options) {
      if (options == null) {
        options = {};
      }
      return this.fetch(_.extend(options, {
        where: query
      }));
    };

    Collection.prototype.save = function(options) {
      return (new sparse.Batch(_.compact(_.map(this.models, function(v, k) {
        if (v.isNew() || v.dirty()) {
          return v;
        }
      })))).exec(options({
        complete: (function(_this) {
          return function(m, r, o) {
            if (options.success) {
              return options.success(m, r, o);
            }
          };
        })(this),
        error: (function(_this) {
          return function(m, r, o) {
            if (options.error) {
              return options.error(m, r, o);
            }
          };
        })(this)
      }));
    };

    function Collection(attrs, opts) {
      Collection.__super__.constructor.call(this, attrs, opts);
      if ((this.className != null ? this.className : this.className = sparse.getConstructorName(this)) === sparse.UNDEFINED_CLASSNAME) {
        console.warn('sparse.Collection requires className to be defined');
      } else {
        this.className = sparse.Inflection.pluralize(this.className);
      }
      this;
    }

    return Collection;

  })(Backbone.Collection);

  sparse.Batch = (function(_super) {
    __extends(Batch, _super);

    function Batch(attrs, opts) {
      Batch.__super__.constructor.call(this, attrs, opts);
    }

    Batch.prototype.url = function() {
      return "" + sparse.API_URI + "/batch";
    };

    Batch.prototype.__processed = [];

    Batch.prototype.processed = function(flatten) {
      if (flatten == null) {
        flatten = true;
      }
      if (flatten) {
        return _.flatten(this.__processed);
      } else {
        return this.__processed;
      }
    };

    Batch.prototype.toJSON = function(options) {
      return JSON.stringify({
        requests: Batch.__super__.toJSON.call(this, options)
      });
    };

    Batch.prototype._memberIsNew = function(attrs) {
      return (attrs.hasOwnProperty('isNew') && attrs.isNew()) || (typeof (attrs.get('objectId')) === 'undefined' || attrs.get('objectId' === null || attrs.get('objectId' === "")));
    };

    Batch.prototype._prepareModel = function(attrs, options) {
      var obj;
      if (options == null) {
        options = {};
      }
      if (!(options.hasOwnProperty('destroy'))) {
        options = _.extend(options, {
          destroy: false
        });
      }
      if (options.destroy && this._memberIsNew(attrs)) {
        obj = null;
      } else {
        obj = {
          method: sparse.CRUD_METHODS[options.destroy ? 'destroy' : (this._memberIsNew(attrs) ? 'create' : 'update')],
          path: "/" + sparse.API_VERSION + "/classes/" + attrs.className + (!this._memberIsNew(attrs) ? '/' + attrs.get('objectId') : '')
        };
        if (!options.destroy) {
          obj.body = attrs;
        }
      }
      return Batch.__super__._prepareModel.call(this, obj, options);
    };

    Batch.prototype.sync = function(method, model, options) {
      var opts;
      if (options == null) {
        options = {};
      }
      if (!model.models || model.models.length === 0) {
        return;
      }
      opts = sparse.apiOPTS();
      opts.data = JSON.stringify({
        requests: (this.__to_remove = model.slice(0, (sparse.MAX_BATCH_SIZE >= 0 && sparse.MAX_BATCH_SIZE < model.models.length ? sparse.MAX_BATCH_SIZE : model.models.length)))
      });
      opts.success = (function(_this) {
        return function(m, r, o) {
          _this.__processed.push(_.map(m, function(v, k, l) {
            return _.chain(_this.__to_remove[k].get('body')).tap(function(_o) {
              if (typeof _o !== 'undefined') {
                return _o.set(v.success);
              } else {
                return _o = v.success;
              }
            }).value();
          }));
          _this.remove(_this.__to_remove, {
            index: 0,
            silent: true
          });
          setTimeout((function() {
            if (model.models.length > 0) {
              return _this.sync(method, _this, options);
            } else {
              return typeof options.complete === "function" ? options.complete(_this.__processed, r, o) : void 0;
            }
          }), 200);
          return typeof options.success === "function" ? options.success(m, r, o) : void 0;
        };
      })(this);
      opts.error = (function(_this) {
        return function(m, r, o) {
          return typeof options.error === "function" ? options.error(m, r, o) : void 0;
        };
      })(this);
      opts.complete = (function(_this) {
        return function(m, r, o) {
          return typeof options.completed === "function" ? options.completed(m, r, o) : void 0;
        };
      })(this);
      return Backbone.sync(method, model, _.extend(_.clone(options), opts));
    };

    Batch.prototype.fetch = function(options) {
      return console.warn('Method: "fetch" is not supported by sparse.Batch. Use sparse.Collection instead');
    };

    Batch.prototype.exec = function(options) {
      return this.sync('create', this, options);
    };

    Batch.prototype.destroy = function(models, options) {
      return this.add(models, _.extend(_.clone(options || {}), {
        destroy: true
      }));
    };

    Batch.prototype.save = function(models, options) {
      return this.add(models, options);
    };

    return Batch;

  })(sparse.Collection);

  sparse.User = (function(_super) {
    __extends(User, _super);

    function User() {
      return User.__super__.constructor.apply(this, arguments);
    }

    User.prototype.defaults = {
      username: null,
      password: null,
      email: null
    };

    User.prototype.__action = 'operate';

    User.prototype.urlMap = {
      create: "" + sparse.API_URI + "/users",
      login: "" + sparse.API_URI + "/login",
      passwordReset: "" + sparse.API_URI + "/requestPasswordReset",
      operate: "" + sparse.API_URI + "/users"
    };

    User.prototype.url = function() {
      return this.urlMap[this.__action] + (this.__action === 'operate' && !this.isNew() ? "/" + (this.get('objectId')) : '');
    };

    User.prototype.signUp = function(attrs, options) {
      return this.save(attrs || null, options);
    };

    User.prototype.logIn = function(username, password, options) {
      var opts;
      this.__action = 'login';
      this.urlMap['login'] = encodeURI(this.urlMap['login'].replace(/\/login+.*/, "/login?username=" + username + "&password=" + password));
      (opts = {}).success = (function(_this) {
        return function(m, r, o) {
          sparse.SESSION_TOKEN = _this.get('sessionToken');
          delete _this.attributes.sessionToken;
          if (options.success) {
            return options.success(m, r, o);
          }
        };
      })(this);
      return this.fetch(_.extend(_.clone(options), opts));
    };

    User.prototype.logOut = function() {
      sparse.SESSION_TOKEN = void 0;
      this.urlMap['login'] = this.urlMap['login'].replace(/\/login+.*/, '/login');
      this.id = null;
      return this.set(this.defaults);
    };

    User.prototype.resetPassword = function(options) {
      var email;
      if ((email = this.get('email')) === null) {
        return false;
      }
      this.__action = 'passwordReset';
      return User.__super__.save.call(this, {
        email: email
      }, options);
    };

    User.prototype.save = function(attrs, opts) {
      this.__action = (this.isNew() ? 'create' : 'operate');
      return User.__super__.save.call(this, attrs, opts);
    };

    User.prototype.destroy = function(options) {
      var opts;
      this.__action = 'operate';
      (opts = {}).success = (function(_this) {
        return function(m, r, o) {
          _this.logOut();
          if (options.success) {
            return options.success(m, r, o);
          }
        };
      })(this);
      return User.__super__.destroy.call(this, _.extend(_.clone(options), opts));
    };

    return User;

  })(sparse.Object);

  sparse.Users = (function(_super) {
    __extends(Users, _super);

    function Users() {
      return Users.__super__.constructor.apply(this, arguments);
    }

    Users.prototype.url = function() {
      return "" + sparse.API_URI + "/users";
    };

    return Users;

  })(sparse.Collection);

  sparse.Query = (function() {
    Query.prototype.__q = {};

    Query.prototype.__include = [];

    Query.prototype.__limit = -1;

    Query.prototype.__skip = 0;

    Query.prototype.__extraOpts = {};

    function Query(classOrName) {
      if (classOrName != null) {
        this.objectClass = _.isString(classOrName) ? sparse.Object._getSubclass(classOrName) : classOrName;
        this.className = this.objectClass.className || sparse.getConstructorName(this.objectClass);
      }
      this.or = this._or;
      this["in"] = this._in;
    }

    Query.prototype.clear = function() {
      return this.__q = {};
    };

    Query.prototype.find = function(opts) {
      if (opts == null) {
        opts = {};
      }
      if (typeof this.objectClass !== 'function') {
        throw 'no valid Class required';
      }
      return (new this.objectClass).sync(sparse.CRUD_METHODS.read, [], _.extend(opts, {
        where: this.__q
      })).then((function(_this) {
        return function(s, r, o) {
          return _.each(r.results, function(v, k) {
            var obj;
            (obj = v.className ? new sparse.Object(v.className) : new _this.objectClass)._finishFetch(v, true);
            return obj;
          });
        };
      })(this));
    };

    Query.prototype.first = function(opts) {
      if (opts == null) {
        opts = {};
      }
      return this.find(_.extend(opts, {
        skip: 0,
        limit: 1
      }));
    };

    Query.prototype.set = function(col, key, val) {
      var _base;
      if (col != null) {
        if ((_base = this.__q)[col] == null) {
          _base[col] = {};
        }
      }
      (this.__q[col] || this.__q)[key] = val;
      return this;
    };

    Query.prototype.getParams = function() {
      return (_.map(_.pairs(this.__q, (function(_this) {
        return function(v, k) {
          return v.join('=');
        };
      })(this)))).join('&');
    };

    Query.prototype.toJSON = function() {
      return JSON.stringify(this.__q);
    };

    Query.prototype.equalTo = function(col, value) {
      return this.set(null, col, value);
    };

    Query.prototype.notEqualTo = function(col, value) {
      return this.set(col, '$ne', value);
    };

    Query.prototype.dontSelect = function(query) {
      return this.set(null, '$dontSelect', {
        query: query
      });
    };

    Query.prototype.exists = function(col) {
      return this.set(col, '$exists', true);
    };

    Query.prototype.doesNotExist = function(col) {
      return this.set(col, '$exists', false);
    };

    Query.prototype.greaterThan = function(col, val) {
      return this.set(col, '$gt', val);
    };

    Query.prototype.greaterThanOrEqualTo = function(col, val) {
      return this.set(col, '$gte', val);
    };

    Query.prototype.lessThan = function(col, value) {
      return this.set(col, '$lt', value);
    };

    Query.prototype.lessThanOrEqualTo = function(col, value) {
      return this.set(col, '$lte', value);
    };

    Query.prototype.contains = function(col, val) {
      return this.set(col, '$regex', "" + (sparse.Query._quote(val)));
    };

    Query.prototype.containsAll = function(col, array) {
      return this.set(null, '$all');
    };

    Query.prototype.containedIn = function(col, value) {
      return this.set(col, '$in', array);
    };

    Query.prototype.notContainedIn = function(col, array) {
      return this.set(col, '$nin', array);
    };

    Query.prototype.select = function(col, query) {
      return this.set(col, '$select', {
        query: query
      });
    };

    Query.prototype.inQuery = function(col, query) {
      return this.set(col, '$inQuery', {
        where: query
      });
    };

    Query.prototype.notInQuery = function(col, query) {
      return this.set(col, '$notInQuery', {
        where: query
      });
    };

    Query.prototype._or = function(query) {
      return (this.__q['$or'] || (this.__q.$or = {})).push(query.__q);
    };

    Query.prototype.relatedTo = function(object, key) {
      if (!(object instanceof sparse.Object) && (object.className != null)) {
        throw new Error('sparse.Query.$relatedTo required object be of Type sparse.Object');
      }
      return this.set(null, "$relatedTo", {
        object: {
          __type: "Pointer",
          objectId: object.get('objectId'),
          className: object.className
        },
        key: "" + key
      });
    };

    Query.prototype.include = function(value) {
      return this.set(null, 'include', "" + value);
    };

    Query.prototype.keys = function(val) {
      return this.set(null, 'keys', "" + value);
    };

    Query.prototype.count = function(value) {
      return this.set(null, 'count', "" + value);
    };

    Query.prototype.order = function(value) {
      return this.set(null, 'order', "" + value);
    };

    Query.prototype.limit = function(value) {
      return this.set(null, 'limit', "" + value);
    };

    Query.prototype.skip = function(value) {
      return this.set(null, 'skip', "" + value);
    };

    Query.prototype.arrayKey = function(col, value) {
      return this.set(null, col, "" + value);
    };

    return Query;

  })();

  sparse.Query.or = function() {
    var Qs, className, q;
    className = null;
    _.each((Qs = _.toArray(arguments)), (function(_this) {
      return function(q) {
        if ((className != null ? className : className = q.className) !== q.className) {
          throw "All queries must be for the same class";
        }
      };
    })(this));
    (q = new sparse.Query(className))._orQuery(Qs);
    return q;
  };

  sparse.Query._quote = function(s) {
    return "\\Q" + s + "\\E";
  };

}).call(this);
